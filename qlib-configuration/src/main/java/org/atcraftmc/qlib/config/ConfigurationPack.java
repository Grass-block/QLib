package org.atcraftmc.qlib.config;

import org.atcraftmc.qlib.FileUtil;
import org.atcraftmc.qlib.PluginConcept;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.InvalidConfigurationException;
import org.bukkit.configuration.file.YamlConfiguration;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.Set;
import java.util.regex.Pattern;

public abstract class ConfigurationPack {
    public static final Pattern REPLACE = Pattern.compile("\\$\\{[a-z-_]+}");
    public static final String FILE_EDIT_HEADER = """
            # This is real configuration/message file where you can do your modifications
            # Add ONLY items you modified here.full files are not  required.
            # This file will not be updated, remind item rename once you updated.
            #
            # For reference template file, go %s
            """;
    public static final String FILE_TEMPLATE_HEADER = """
            #this file is only for template which shows you all the items and defaults.
            #structures are as follows here, you can choose only items that you want to modify.
            #DO NOT EDIT THIS FILE. IT IS JUST A TEMPLATE AND WILL BEE COVERED EVERY START.
            #
            #do your modifications in file: %s
            """;

    protected final String id;
    protected final PluginConcept provider;
    protected final YamlConfiguration dom = new YamlConfiguration();

    protected ConfigurationPack(String id, PluginConcept provider) {
        this.id = id;
        this.provider = provider;
    }

    @Override
    public abstract String toString();

    @Override
    public int hashCode() {
        return toString().hashCode();
    }

    public String getId() {
        return id;
    }

    public PluginConcept getProvider() {
        return provider;
    }

    //----[file]----
    public String getTemplateDirectory() {
        return getTemplateFile();
    }

    public String getStorageDirectory() {
        return getStorageFile();
    }


    public abstract String getTemplateFile();

    public abstract String getStorageFile();

    public abstract String getTemplateResource();


    public File createStorageFile(boolean enforce) {
        var logger = this.provider.logger();
        var file = new File(this.provider.folder() + getStorageFile());

        if (file.exists() && file.length() > 0) {
            if (!enforce) {
                return file;
            }
        }

        if (file.getParentFile().mkdirs()) {
            logger.info("created storage file folder: {}", file.getParentFile().getAbsolutePath());
        }
        try {
            if (file.createNewFile()) {
                logger.info("created storage file: {}", file.getAbsolutePath());
            }
        } catch (IOException e) {
            logger.info("failed to create storage file: {}", file.getAbsolutePath());
            logger.catching(e);
        }

        try (var stream = new FileOutputStream(file, false); var writer = new OutputStreamWriter(stream, StandardCharsets.UTF_8)) {
            writer.write(FILE_EDIT_HEADER.formatted(getTemplateFile()));
            writer.write(getRootSectionName() + ":");
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e);
        } catch (IOException e) {
            logger.info("failed to write storage file: {}", file.getAbsolutePath());
            logger.catching(e);
        }

        return file;
    }

    public void createTemplateFile() {
        var logger = this.provider.logger();
        var file = new File(this.provider.folder() + getTemplateFile());

        if (file.getParentFile().mkdirs()) {
            logger.info("created template file folder: {}", file.getParentFile().getAbsolutePath());
        }
        try {
            if (file.createNewFile()) {
                logger.info("created template file: {}", file.getAbsolutePath());
            }
        } catch (IOException e) {
            logger.info("failed to create template file: {}", file.getAbsolutePath());
            logger.catching(e);
        }

        try (var stream = new FileOutputStream(file, false); var writer = new OutputStreamWriter(stream, StandardCharsets.UTF_8)) {
            writer.write(FILE_TEMPLATE_HEADER.formatted(getStorageFile()));
            try (var template = provider.handle().getClass().getResourceAsStream(getTemplateResource())) {
                assert template != null;
                writer.write(new String(template.readAllBytes(), StandardCharsets.UTF_8));
            }
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e);
        } catch (IOException e) {
            logger.info("failed to write template file: {}", file.getAbsolutePath());
            logger.catching(e);
        }
    }

    public File getFile() {
        return FileUtil.tryReleaseAndGetFile(getTemplateDirectory(), getStorageDirectory());
    }

    private void merge(ConfigurationSection current, ConfigurationSection mod) {
        for (var key : current.getKeys(false)) {
            if (mod == null) {
                continue;
            }
            if (!mod.contains(key)) {
                continue;
            }

            if (current.isConfigurationSection(key)) {
                var c = current.getConfigurationSection(key);
                var m = mod.getConfigurationSection(key);

                assert c != null;

                merge(c, m);
                continue;
            }

            current.set(key, mod.get(key));
        }
    }

    public String processDOM(String s) {
        return Queries.applyEnvironmentVars(s);
    }

    public void load() {
        var custom = new YamlConfiguration();

        try (var template = provider.handle().getClass()
                .getResourceAsStream(getTemplateResource()); var mod = new FileInputStream(createStorageFile(false))) {
            assert template != null;

            this.dom.loadFromString(processDOM(new String(template.readAllBytes(), StandardCharsets.UTF_8)).replace("\ud83c\udf10", ""));

            custom.loadFromString(processDOM(new String(mod.readAllBytes(), StandardCharsets.UTF_8)));

            merge(this.dom, custom);
        } catch (IOException | InvalidConfigurationException e) {
            throw new RuntimeException(e);
        }
    }

    public void save() {
        /*
        try {
            YamlUtil.saveUTF8(this.dom, new FileOutputStream(getFile()));
        } catch (IOException e) {
            logger.severe(e.getMessage());
        }
         */
    }

    public void reload() {
        this.save();
        this.load();
    }

    public void restore() {
        this.createStorageFile(true);
        load();
    }

    public void sync(boolean clean) {
        var logger = this.provider.logger();
        try {
            var template = new YamlConfiguration();
            var srcDir = getTemplateDirectory();

            var is = this.provider.handle().getClass().getResourceAsStream(srcDir);
            if (is == null) {
                throw new RuntimeException("source not found: " + srcDir);
            }
            YamlUtil.loadUTF8(template, is);
            YamlUtil.update(this.dom, template, clean, 3);
            this.save();
        } catch (Exception e) {
            logger.warn("failed to sync config {}: {}", this.toString(), e.getMessage());
        }
    }


    //----[dom]----
    public abstract String getRootSectionName();

    public String getDom() {
        return this.dom.saveToString();
    }

    public ConfigurationSection getRootSection() {
        return this.dom.getConfigurationSection(getRootSectionName());
    }

    public ConfigurationSection getNamespace(String namespace) {
        return this.getRootSection().getConfigurationSection(namespace);
    }

    public boolean hasEntry(String namespace, String id) {
        ConfigurationSection section = this.getNamespace(namespace);
        if (section == null) {
            return false;
        }
        return section.contains(id);
    }

    public Set<String> getEntries(String namespace) {
        ConfigurationSection section = this.getNamespace(namespace);
        if (section == null) {
            return Set.of();
        }
        return section.getKeys(false);
    }

    public Set<String> getNamespaces() {
        if (this.getRootSection() == null) {
            return Set.of();
        }
        return this.getRootSection().getKeys(false);
    }

    public String getRegisterId() {
        return getId();
    }
}
